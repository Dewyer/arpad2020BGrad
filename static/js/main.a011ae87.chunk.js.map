{"version":3,"sources":["components/Construction/Construction.module.scss","assets/post.png","utils/StudentUtil.ts","models/UserListItem.ts","utils/AiUtil.ts","components/Construction/index.tsx","components/Construction/Construction.tsx","components/App/index.tsx","components/App/App.tsx","serviceWorker.ts","index.tsx"],"names":["module","exports","StudentUitl","uid","fetch","peopleDataStr","json","pplData","newCache","ii","peopleJson","length","this","fetchStudentData","stData","push","name","st","status","id","tabloBase64","CachedUserList","ff","pp","Promise","res","rej","fr","FileReader","addEventListener","e","target","result","readAsDataURL","payload","loadFileToBase64","tabloPhoto","tabloBase","AiUtil","matchSingleFaceFromBase64","tabloDesc","console","log","undefined","teaching","teacherPhotos","teacherPhoto","baseTeacher","descriptor","description","ownPhotosBase64","tabloDescriptor","teachingDescriptor","uuid","v4","loaded","faceapi","faceRecognitionNet","load","ssdMobilenetv1","faceLandmark68Net","loadALlFaceData","facePool","obj","arr","Float32Array","persons","require","peopleData","entry","personId","possibilities","Array","from","labeledDescriptors","map","xx","fas","ll","floatArrayFromObj","faceMatcher","FaceMatcher","b64","desc","match","matchDescriptor","label","img","Image","src","withFaceLandmarks","withFaceDescriptor","Construction","props","className","styles","container","href","App","useEffect","a","init","loadFaceApi","Boolean","window","location","hostname","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.a011ae87.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"container\":\"Construction_container__37-su\"};","module.exports = __webpack_public_path__ + \"static/media/post.63200e0d.png\";","import StudentPage, { StudentPagePayload } from \"../models/StudentPage\";\nimport AiUtil from \"./AiUtil\";\nimport FaceDescriptor from \"../models/FaceDescriptor\";\nimport uuid from \"uuid\";\nimport StudentPageModel from \"../models/StudentPage\";\nimport { UserListItem, fromStudentPageModel } from \"../models/UserListItem\";\nimport peopleJson from \"../assets/people.json\";\n\nexport default abstract class StudentUitl\n{\n\tpublic static CachedUserList : UserListItem[]|undefined = undefined;\n\n\tpublic static async init()\n\t{\n\n\t}\n\n\tpublic static async fetchStudentData(uid:string) : Promise<StudentPageModel | null>\n\t{\n\t\ttry\n\t\t{\n\t\t\tlet peopleDataStr = await fetch(`/people/${uid}.json`);\n\t\t\tlet pplData = await peopleDataStr.json() as StudentPageModel;\n\t\t\treturn pplData;\n\t\t}\n\t\tcatch\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic static async fetchAndCacheUserList()\n\t{\n\t\tlet newCache:UserListItem[] = [];\n\t\tfor (let ii = 0; ii < peopleJson.length;ii++)\n\t\t{\n\t\t\tlet stData = await this.fetchStudentData(peopleJson[ii]);\n\t\t\tif (stData)\n\t\t\t{\n\t\t\t\tnewCache.push(fromStudentPageModel(stData))\n\t\t\t}\n\t\t}\n\t\tthis.CachedUserList = newCache;\n\t}\n\n\tpublic static async loadFileToBase64(ff:File) : Promise<string>\n\t{\n\t\tlet pp = new Promise<string>((res,rej)=>\n\t\t{\n\t\t\tvar fr = new FileReader();\n\t\t\tfr.addEventListener(\"load\",(e)=>\n\t\t\t{\n\t\t\t\tif (e.target){\n\t\t\t\t\tres(e.target!.result as string);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\trej(\"Err no target\");\n\t\t\t\t}\n\t\t\t});\n\t\t\tfr.readAsDataURL(ff);\n\t\t});\n\t\tlet res = await pp;\n\t\treturn res;\n\t}\n\n\tpublic static async makeStudentPageObject(payload: StudentPagePayload) : Promise<StudentPage |Â undefined>\n\t{\n\t\tlet tabloBase = await this.loadFileToBase64(payload.tabloPhoto);\n\t\tlet tabloDesc = await AiUtil.matchSingleFaceFromBase64(tabloBase);\n\t\tconsole.log(tabloBase);\n\t\tif (!tabloDesc)\n\t\t{\n\t\t\treturn undefined;\n\t\t}\n\t\tlet teaching:FaceDescriptor[ ] =[ ];\n\t\tfor (let ii = 0;ii< payload.teacherPhotos.length;ii++)\n\t\t{\n\t\t\tlet teacherPhoto = payload.teacherPhotos[ii];\n\t\t\tlet baseTeacher = await this.loadFileToBase64(teacherPhoto);\n\t\t\tlet descriptor = await AiUtil.matchSingleFaceFromBase64(baseTeacher);\n\t\t\tif (descriptor)\n\t\t\t{\n\t\t\t\tteaching.push(descriptor);\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tname:payload.name,\n\t\t\tdescription:payload.description,\n\t\t\townPhotosBase64:[ ],\n\t\t\ttabloDescriptor:tabloDesc!,\n\t\t\ttabloBase64:tabloBase,\n\t\t\tteachingDescriptor:teaching,\n\t\t\tid:uuid.v4(),\n\t\t\tstatus:payload.status\n\t\t};\n\t}\n}\n","import StudentPageModel from \"./StudentPage\";\n\nexport interface UserListItem\n{\n\tname:string,\n\tstatus:string,\n\tid:string,\n\ttabloBase64:string\n}\n\nexport function fromStudentPageModel(st:StudentPageModel) : UserListItem\n{\n\treturn {\n\t\tname:st.name,\n\t\tstatus:st.status,\n\t\tid:st.id,\n\t\ttabloBase64:st.tabloBase64\n\t};\n}\n","import * as faceapi from \"face-api.js\";\nimport FaceDescriptor from \"../models/FaceDescriptor\";\nimport StudentPage from \"../models/StudentPage\";\nimport FacePoolEntry from \"../models/FacePoolEntry\";\nimport { FaceMatcher } from \"face-api.js\";\nimport StudentUitl from \"./StudentUtil\";\n\nexport default abstract class AiUtil\n{\n\tstatic loaded: boolean;\n\tstatic facePool:FacePoolEntry[ ] = [ ];\n\tstatic faceMatcher:FaceMatcher;\n\n\tpublic static async init()\n\t{\n\t\tif (!this.loaded)\n\t\t{\n\t\t\tawait faceapi.nets.faceRecognitionNet.load(\"/aimodels\");\n\t\t\tawait faceapi.nets.ssdMobilenetv1.load(\"/aimodels\");\n\t\t\tawait faceapi.nets.faceLandmark68Net.load(\"/aimodels\");\n\t\t\tconsole.log(\"AI util loaded models\");\n\t\t\tawait this.loadALlFaceData();\n\t\t\tconsole.log(\"Loading people face data\");\n\t\t\tconsole.log(this.facePool.length,\" entries loaded\");\n\n\t\t}\n\t\tthis.loaded = true;\n\t}\n\n\tpublic static floatArrayFromObj(obj:any):Float32Array\n\t{\n\t\tlet arr:number[ ] = [ ];\n\t\tfor(let ii in obj)\n\t\t{\n\t\t\tarr.push(obj[ii]);\n\t\t}\n\t\tlet fasz = new Float32Array(arr);\n\t\treturn fasz;\n\t}\n\n\tpublic static async loadALlFaceData()\n\t{\n\t\tlet persons:string[ ] = require(\"../assets/people.json\");\n\t\tfor (let ii = 0; ii < persons.length;ii++)\n\t\t{\n\t\t\tconst peopleData = await StudentUitl.fetchStudentData(persons[ii]);\n\t\t\tif (!peopleData)\n\t\t\t\tcontinue;\n\n\t\t\tlet entry:FacePoolEntry ={\n\t\t\t\tpersonId:peopleData.id,\n\t\t\t\tpossibilities:Array.from(peopleData.teachingDescriptor)\n\t\t\t};\n\t\t\tentry.possibilities.push(peopleData.tabloDescriptor);\n\t\t\tthis.facePool.push(entry);\n\t\t\tconsole.log(peopleData.name);\n\t\t}\n\t\tconsole.log(this.facePool);\n\t\tconst labeledDescriptors = this.facePool.map(xx=>{\n\n\t\t\tlet fas:Float32Array[ ] = xx.possibilities.map(ll=>this.floatArrayFromObj(ll.descriptor));\n\t\t\treturn (new faceapi.LabeledFaceDescriptors(\n\t\t\t\txx.personId,\n\t\t\t\tfas));\n\t\t});\n\t\tthis.faceMatcher = new FaceMatcher(labeledDescriptors);\n\t}\n\n\tpublic static async witchFaceFromBase64(b64:string):Promise<string>\n\t{\n\t\tconst desc = await this.matchSingleFaceFromBase64(b64);\n\t\tif (desc)\n\t\t{\n\t\t\tconsole.log(\"found face on img\");\n\t\t\tconst match = this.faceMatcher.matchDescriptor(desc.descriptor);\n\t\t\tconsole.log(match);\n\t\t\treturn match.label;\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static async matchSingleFaceFromBase64(b64: string): Promise<FaceDescriptor | undefined>\n\t{\n\t\tconst img = new Image();\n\t\timg.src = b64;\n\t\tlet desc = await faceapi.detectSingleFace(img).withFaceLandmarks().withFaceDescriptor();\n\t\treturn desc;\n\t}\n\n}\n","import Construction from \"./Construction\";\r\n\r\nexport default Construction;\r\n","import React from 'react';\nimport styles from \"./Construction.module.scss\"\n\nexport interface Props\n{\n\n}\n\nconst Construction:React.FC<Props> = (props:Props) =>\n{\n\n\treturn (\n\t\t<div className={styles.container}>\n\t\t\t<img src={require(\"../../assets/post.png\")} />\n\t\t\t<h2>Ez az oldal fejlesztÃ©s alatt van !</h2>\n\t\t\t<a href=\"https://www.youtube.com/watch?v=dQw4w9WgXcQ\">Addig is</a>\n\t\t</div>\n\t);\n}\n\nexport default Construction;\n","import App from \"./App\";\r\nexport default App;\r\n","import React, { useEffect } from 'react';\nimport logo from './logo.svg';\nimport './App.css';\nimport { BrowserRouter, Switch, Route } from 'react-router-dom';\nimport MainPageContainer from '../MainPageContainer/MainPage-container';\nimport NavMenuWrapper from '../NavMenuWrapper';\nimport FaceRecognitionPage from '../FaceRecognitionPage';\nimport PageMakerPage from '../PageMakerPage';\nimport AiUtil from \"../../utils/AiUtil\";\nimport StudentPage from '../StudentPage';\nimport PeopleListPage from '../PeopleListPage';\nimport Construction from '../Construction';\n\nconst App = () =>\n{\n\tuseEffect(()=>{\n\t\tasync function loadFaceApi()\n\t\t{\n\t\t\tAiUtil.init();\n\t\t}\n\t\tloadFaceApi();\n\t},[ ]);\n\n\treturn <Construction/>\n\t/*\n\treturn (\n\t\t<BrowserRouter>\n\t\t\t<NavMenuWrapper>\n\t\t\t\t<Switch>\n\t\t\t\t\t<Route exact path=\"/\" component={MainPageContainer}/>\n\t\t\t\t\t<Route exact path=\"/recognise\" component={FaceRecognitionPage}/>\n\t\t\t\t\t<Route exact path=\"/upload\" component={PageMakerPage} />\n\t\t\t\t\t<Route exact path=\"/p/:id\" component={StudentPage} />\n\t\t\t\t\t<Route exact path=\"/list\" component={PeopleListPage} />\n\t\t\t\t</Switch>\n\t\t\t</NavMenuWrapper>\n\t\t</BrowserRouter>\n\t);*/\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\ntype Config = {\r\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\r\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\r\n};\r\n\r\nexport function register(config?: Config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(\r\n      process.env.PUBLIC_URL,\r\n      window.location.href\r\n    );\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl: string, config?: Config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' }\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './styles/index.scss';\nimport App from './components/App';\nimport * as serviceWorker from './serviceWorker';\nimport 'react-markdown-editor-lite/lib/index.css';\nimport \"react-toggle/style.css\";\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}